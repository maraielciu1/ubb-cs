# Lab 8: Code Generation Implementation Details

## Overview

This lab implements a **syntax-directed translation** from the custom statistical language to C. The translation is performed during parsing using semantic actions attached to grammar rules.

## Architecture

```
Source Code (.src)
       ↓
   Scanner (Lab 6)
       ↓
   PIF + Symbol Table
       ↓
   Parser with Code Gen (Lab 8)
       ↓
   Generated C Code
       ↓
   GCC Compiler
       ↓
   Executable
```

## Key Components

### 1. Parser Grammar (`parser.y`)

The parser uses a **%union** to associate C code strings with non-terminals:

```c
%union {
    char* code;
}
```

Each non-terminal that generates code has type `<code>`:

```c
%type <code> program statement expression term factor ...
```

### 2. Semantic Actions

Each grammar rule includes a semantic action that builds C code:

```c
assignment_statement:
    IDENTIFIER ASSIGN expression SEMICOLON {
        print_production("assignment -> ID = expr");
        $$ = cat(4, new_str($1), new_str(" = "), $3, new_str(";\n"));
    }
    ;
```

### 3. String Management

Two helper functions manage code generation:

#### `new_str(const char* s)`
- Duplicates a string for the code buffer
- Used for literals and terminal values

#### `cat(int count, ...)`
- Concatenates multiple strings
- **Automatically frees** the constituent strings after concatenation
- Returns the newly allocated concatenated string

Example:
```c
$$ = cat(4, 
    new_str($1),        // Identifier
    new_str(" = "),     // Equals sign
    $3,                 // Expression (already a string)
    new_str(";\n")      // Semicolon and newline
);
```

### 4. PIF Reader (`pif_lexer.c`)

Instead of using Flex, the parser reads tokens from the PIF file generated by the scanner.

#### Custom yylex()
- Reads PIF line by line
- Parses format: `TOKEN_NAME: position`
- Maps token names to token codes
- Retrieves lexeme values from symbol table

#### Symbol Table Integration
- Loads `st.txt` at initialization
- Creates index-to-value mapping
- Strips `!` prefix from identifiers (C doesn't allow `!` in names)

```c
// For identifiers, strip the leading '!' if present
if (token_code == IDENTIFIER && value[0] == '!') {
    yylval.code = strdup(value + 1);  // Skip the '!' character
} else {
    yylval.code = strdup(value);
}
```

### 5. Runtime Library

The generated C code includes a runtime library for statistical operations:

```c
double calc_mean(double* arr, int n) { ... }
double calc_stdev(double* arr, int n) { ... }
double sample_normal(double param) { ... }
```

These functions are embedded in every generated program.

## Translation Examples

### Variable Declaration

**Source:**
```
INT !x = 5;
```

**Generated C:**
```c
int x = 5;
```

**Grammar Rule:**
```c
declaration_statement:
    type IDENTIFIER ASSIGN expression SEMICOLON {
        $$ = cat(6, $1, new_str(" "), new_str($2), 
                    new_str(" = "), $4, new_str(";\n"));
    }
```

### Control Flow (IF-ELSE)

**Source:**
```
IF (!x < !y) {
    WRITE(!x);
} ELSE {
    WRITE(!y);
}
```

**Generated C:**
```c
if (x < y) {
printf("Output: %g\n", (double)x);
} else {
printf("Output: %g\n", (double)y);
}
```

### Statistical Functions

**Source:**
```
FLOAT !mean_val = MEAN(!x, !y, 15);
```

**Generated C:**
```c
double mean_val = calc_mean((double[]){x, y, 15}, 
                            sizeof((double[]){x, y, 15})/sizeof(double));
```

**Implementation Details:**
- Uses C99 compound literal syntax `(double[]){...}`
- Automatically counts arguments using `sizeof()`
- No need to track argument count in parser

**Grammar Rule:**
```c
statistical_function_call:
    function_name LPAREN argument_list RPAREN {
        char* args = $3;
        char* args_dup = strdup(args);
        $$ = cat(6, $1, 
                    new_str("((double[]){"), args, 
                    new_str("}, sizeof((double[]){"), new_str(args_dup), 
                    new_str("})/sizeof(double))"));
        free(args_dup);
    }
```

### Sampling from Distributions

**Source:**
```
!sample_val = SAMPLE(NORMAL, 1.0);
```

**Generated C:**
```c
sample_val = sample_normal(1.0);
```

**Grammar Rule:**
```c
sampling_statement:
    IDENTIFIER ASSIGN SAMPLE LPAREN distribution_type COMMA expression RPAREN SEMICOLON {
        $$ = cat(6, new_str($1), new_str(" = sample_"), 
                    $5, new_str("("), $7, new_str(");\n"));
    }
```

## Memory Management

### Allocation
- All code strings are allocated with `strdup()` or `malloc()`
- Returned from semantic actions as `$$`

### Deallocation
- The `cat()` function **frees** all its arguments after concatenation
- Top-level result in `program` rule is freed manually
- PIF lexer frees symbol table entries on cleanup

### Common Pitfall: Double Use of Variables

❌ **WRONG:**
```c
char* args = $3;
$$ = cat(6, ..., args, ..., args, ...);  // Second use is freed!
```

✅ **CORRECT:**
```c
char* args = $3;
char* args_dup = strdup(args);
$$ = cat(6, ..., args, ..., new_str(args_dup), ...);
free(args_dup);
```

## Output Files

### `out/productions.txt`
Lists all grammar productions applied during parsing:

```
1: type -> INT
2: factor -> const
3: term -> factor
4: expr -> term
5: decl -> type ID = expr
...
```

### `out/generated_program.c`
Complete C program with:
- Standard library includes
- Runtime library functions
- Translated source code in `main()`

## Compilation

The generated C code uses:
- **C99 standard** (compound literals)
- **Math library** (-lm flag for `sqrt`, `log`, `cos`, etc.)

```bash
gcc out/generated_program.c -o program -lm
```

## Limitations

1. **No type checking** - The translator assumes the source code is type-correct
2. **No optimization** - Generated code is straightforward translation
3. **Limited error messages** - Syntax errors show line numbers from PIF, not original source
4. **No arrays** - Only scalar variables supported
5. **Simple I/O** - All output uses generic `%g` format

## Future Enhancements

1. **Better error reporting** - Map PIF line numbers back to source lines
2. **Type checking** - Validate type compatibility during translation
3. **Optimizations** - Constant folding, dead code elimination
4. **Array support** - Add array declarations and indexing
5. **More distributions** - Implement binomial and Poisson sampling
6. **T-test implementation** - Add actual statistical test function
7. **Formatted I/O** - Support custom format strings in WRITE()

## Testing

Run the complete test suite:

```bash
./demo.sh
```

Create custom test programs:

1. Write source in `scanner/test.src`
2. Run: `./demo.sh`
3. Check generated C code: `cat parser/out/generated_program.c`
4. Run the program: `parser/out/program`

## Key Learnings

1. **Syntax-directed translation** is powerful for code generation
2. **Careful memory management** is critical when building strings
3. **Semantic actions** should be simple and focused
4. **Runtime libraries** can simplify code generation
5. **PIF-based parsing** decouples lexical and syntax analysis
