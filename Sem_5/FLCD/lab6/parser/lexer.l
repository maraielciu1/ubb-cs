%option noyywrap yylineno nodefault

%{
#include <stdio.h>
#include <string.h>
#include "symbol_table.h"
#include "fa_rg/fa_rg.h"

// Include parser header (generated by yacc/bison)
// Both yacc and bison (with -y flag) generate y.tab.h
// This defines all token macros that we return
#include "y.tab.h"

static long yycolumn = 1;
#define YY_USER_ACTION yycolumn += yyleng;
static void reset_col(void){ yycolumn = 1; }

// FA instances for identifiers and constants
static FiniteAutomata* fa_id = NULL;
static FiniteAutomata* fa_int = NULL;
static FiniteAutomata* fa_float = NULL;
static FiniteAutomata* fa_char = NULL;
static FiniteAutomata* fa_string = NULL;

// Initialize FAs
static void init_fas(void) {
    if (fa_id == NULL) {
        fa_id = create_identifier_fa();
        fa_int = create_int_constant_fa();
        fa_float = create_float_constant_fa();
        fa_char = create_char_constant_fa();
        fa_string = create_string_constant_fa();
    }
}

// Token type codes (before y.tab.h macros override)
#define TOKEN_TYPE_IDENTIFIER 1
#define TOKEN_TYPE_INT_CONST 2
#define TOKEN_TYPE_FLOAT_CONST 3
#define TOKEN_TYPE_CHAR_CONST 4
#define TOKEN_TYPE_STRING_CONST 5

// Verify token using FA - returns token type code
static int verify_token_type(const char* text) {
    init_fas();
    
    // Try identifier first
    if (fa_verify(fa_id, text)) {
        return TOKEN_TYPE_IDENTIFIER;
    }
    // Try float constant
    if (fa_verify(fa_float, text)) {
        return TOKEN_TYPE_FLOAT_CONST;
    }
    // Try integer constant
    if (fa_verify(fa_int, text)) {
        return TOKEN_TYPE_INT_CONST;
    }
    // Try character constant
    if (fa_verify(fa_char, text)) {
        return TOKEN_TYPE_CHAR_CONST;
    }
    // Try string constant
    if (fa_verify(fa_string, text)) {
        return TOKEN_TYPE_STRING_CONST;
    }
    
    return -1; // Not recognized by any FA
}

// Cleanup FAs (called from parser)
void cleanup_fas(void) {
    if (fa_id) { fa_free(fa_id); fa_id = NULL; }
    if (fa_int) { fa_free(fa_int); fa_int = NULL; }
    if (fa_float) { fa_free(fa_float); fa_float = NULL; }
    if (fa_char) { fa_free(fa_char); fa_char = NULL; }
    if (fa_string) { fa_free(fa_string); fa_string = NULL; }
}
%}

EQOP          "=="
NEQOP         "!="
LEOP          "<="
GEOP          ">="
ANDOP         "&&"
OROP          "\|\|"
WS            [ \t\r]+
NEWLINE       \n

POTENTIAL_ID  \![A-Za-z][A-Za-z0-9_]*
POTENTIAL_FLOAT [+\-]?[0-9]+\.[0-9]+
POTENTIAL_INVALID_FLOAT [+\-]?[0-9]+\.[0-9]+\.[0-9.]+
POTENTIAL_INT [+\-]?[0-9]+
POTENTIAL_CHAR \'[A-Za-z0-9_]\'
POTENTIAL_STRING \"[^\"]*\"

%%

{WS}          { }
{NEWLINE}     { reset_col(); }

{EQOP}        { return EQ; }
{NEQOP}       { return NEQ; }
{LEOP}        { return LE; }
{GEOP}        { return GE; }
{ANDOP}       { return AND; }
{OROP}        { return OR; }

"("           { return LPAREN; }
")"           { return RPAREN; }
"["           { return LBRACK; }
"]"           { return RBRACK; }
"{"           { return LBRACE; }
"}"           { return RBRACE; }
";"           { return SEMICOLON; }
","           { return COMMA; }
"."           { return DOT; }
"+"           { return PLUS; }
"-"           { return MINUS; }
"*"           { return MUL; }
"/"           { return DIV; }
"%"           { return MOD; }
"="           { return ASSIGN; }
"<"           { return LT; }
">"           { return GT; }
"~"           { return TILDE; }

"START"    { return START; }
"STOP"     { return STOP; }
"IF"       { return IF; }
"THEN"     { return THEN; }
"ELSE"     { return ELSE; }
"WHILE"    { return WHILE; }
"READ"     { return READ; }
"WRITE"    { return WRITE; }
"INT"      { return INT; }
"FLOAT"    { return FLOAT; }
"STRING"   { return STRING; }
"CHAR"     { return CHAR; }
"MEAN"     { return MEAN; }
"STDEV"    { return STDEV; }
"TTEST"    { return TTEST; }
"SAMPLE"   { return SAMPLE; }
"NORMAL"   { return NORMAL; }
"BINOMIAL" { return BINOMIAL; }
"POISSON"  { return POISSON; }

{POTENTIAL_ID} {
    int token_type = verify_token_type(yytext);
    if (token_type == TOKEN_TYPE_IDENTIFIER) {
        st_insert(yytext);
        return IDENTIFIER;  // Return y.tab.h token value
    } else {
        fprintf(stderr, "Lexical error at line %d, col %ld: Invalid identifier format '%s'\n",
                yylineno, yycolumn, yytext);
        return -1;
    }
}

{POTENTIAL_INVALID_FLOAT} {
    fprintf(stderr, "Lexical error at line %d, col %ld: Invalid float constant '%s'\n",
            yylineno, yycolumn, yytext);
    return -1;
}

{POTENTIAL_FLOAT} {
    int token_type = verify_token_type(yytext);
    if (token_type == TOKEN_TYPE_FLOAT_CONST) {
        st_insert(yytext);
        return FLOAT_CONST;  // Return y.tab.h token value
    } else {
        fprintf(stderr, "Lexical error at line %d, col %ld: Invalid float constant format '%s'\n",
                yylineno, yycolumn, yytext);
        return -1;
    }
}

{POTENTIAL_INT} {
    int token_type = verify_token_type(yytext);
    if (token_type == TOKEN_TYPE_INT_CONST) {
        st_insert(yytext);
        return INT_CONST;  // Return y.tab.h token value
    } else {
        fprintf(stderr, "Lexical error at line %d, col %ld: Invalid integer constant format '%s'\n",
                yylineno, yycolumn, yytext);
        return -1;
    }
}

{POTENTIAL_CHAR} {
    int token_type = verify_token_type(yytext);
    if (token_type == TOKEN_TYPE_CHAR_CONST) {
        st_insert(yytext);
        return CHAR_CONST;  // Return y.tab.h token value
    } else {
        fprintf(stderr, "Lexical error at line %d, col %ld: Invalid character constant format '%s'\n",
                yylineno, yycolumn, yytext);
        return -1;
    }
}

{POTENTIAL_STRING} {
    int token_type = verify_token_type(yytext);
    if (token_type == TOKEN_TYPE_STRING_CONST) {
        st_insert(yytext);
        return STRING_CONST;  // Return y.tab.h token value
    } else {
        fprintf(stderr, "Lexical error at line %d, col %ld: Invalid string constant format '%s'\n",
                yylineno, yycolumn, yytext);
        return -1;
    }
}

.             { 
    fprintf(stderr, "Lexical error at line %d, col %ld: Unrecognized token '%s'\n",
            yylineno, yycolumn, yytext);
    return -1;
}

%%

