# Lab 6: Syntactical Analysis (Parsing)

This lab implements a parser for the mini-DSL using yacc/bison, integrated with the lexer from Lab 5.

## Requirements

1. **Grammar Definition**: The grammar is defined in `parser/parser.y` based on the syntax rules from Lab 1.
2. **Parsing**: Uses yacc/bison to perform syntactical analysis.
   - **Input**: Grammar (defined in parser.y) and PIF file (from scanner)
   - **Output**: String of productions (in `out/productions.txt`)
3. **Integration**: The parser reads from PIF files generated by the scanner (Lab 5), demonstrating the integration of scanning with parsing.

## Structure

```
lab6/
├── parser/
│   ├── parser.y          # Grammar definition and parser rules
│   ├── lexer.l           # Lexer integrated with parser
│   ├── tokens.h          # Token definitions
│   ├── symbol_table.h/c  # Symbol table implementation
│   ├── Makefile          # Build configuration
│   └── out/
│       └── productions.txt  # Output: string of productions
├── test.src              # Test file
└── README.md             # This file
```

## Building

```bash
cd parser
make
```

The Makefile automatically detects whether `bison` or `yacc` is available and uses the appropriate tool.

## Usage

```bash
cd parser
./parser <pif_file>
```

The parser takes a PIF (Program Internal Form) file as input, which is the output from the scanner (Lab 5).

Example:
```bash
# First, generate PIF using the bundled scanner copy (Lab 5)
cd scanner
make           
./scanner ./test.src
# This produces ../scanner/out/pif.txt

# Then parse the PIF
cd ../parser
make        
./parser ../scanner/out/pif.txt
```

## Output

The parser generates `out/productions.txt` containing the sequence of grammar productions applied during parsing, numbered sequentially.

Example output:
```
1: constant -> INT_CONST
2: factor -> constant
3: term -> factor
4: expression -> term
...
```

## Grammar

The grammar implements all constructs from the mini-DSL:
- Program structure (START ... STOP)
- Statements: assignment, if, while, I/O, declaration, statistical
- Expressions with operators
- Conditions with relational and logical operators
- Statistical functions and distributions

## Integration

The lexer and parser are fully integrated:
- Lexer (`lexer.l`) uses flex to tokenize input
- Parser (`parser.y`) uses yacc/bison to parse tokens
- Both share the same token definitions via `y.tab.h`
- Symbol table is shared between lexer and parser
- Finite automata from Lab 5 are used for token verification

## Dependencies

- `flex` (or `lex`) - for lexical analysis
- `bison` (or `yacc`) - for syntax analysis
- `gcc` - for compilation
- Lab 5's `fa_rg` module (linked via symlink)

